(ns clj-dbase.core-test
  (:require [clojure.test :refer :all]
            [clj-dbase.core :as sut]
            [clojure.java.io :as io]))

(def dbase-sample
  "A dbase sample file in in byte hex code."
  [0x03 0x77 0x0a 0x01 0x01 0x00 0x00 0x00 0x21 0x01 0x43 0x00 0x00 0x00 0x00 0x00
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x4b 0x4e 0x51 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x43 0x11 0x00 0x6b 0x46
0x03 0x00 0x00 0x00 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x49 0x44 0x5f 0x43 0x50 0x45 0x00 0x00 0x00 0x00 0x00 0x43 0x14 0x00 0x6b 0x46
0x0f 0x00 0x00 0x00 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x50 0x52 0x45 0x49 0x53 0x00 0x00 0x00 0x00 0x00 0x00 0x4e 0x1a 0x00 0x6b 0x46
0x0c 0x04 0x00 0x00 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x57 0x4b 0x5a 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x43 0x26 0x00 0x6b 0x46
0x03 0x00 0x00 0x00 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x56 0x45 0x52 0x42 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x4e 0x29 0x00 0x6b 0x46
0x07 0x00 0x00 0x00 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x45 0x49 0x4e 0x48 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x4e 0x30 0x00 0x6b 0x46
0x07 0x00 0x00 0x00 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x44 0x41 0x55 0x45 0x52 0x00 0x00 0x00 0x00 0x00 0x00 0x4e 0x37 0x00 0x6b 0x46
0x09 0x00 0x00 0x00 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x4d 0x49 0x4e 0x55 0x54 0x45 0x4e 0x00 0x00 0x00 0x00 0x4e 0x40 0x00 0x6b 0x46
0x0a 0x02 0x00 0x00 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x0d 0x20 0x4e 0x4f 0x36 0x31 0x30 0x36 0x35 0x34 0x39 0x38 0x30 0x20 0x20 0x20
0x20 0x20 0x20 0x20 0x20 0x20 0x20 0x20 0x31 0x32 0x39 0x2e 0x38 0x39 0x32 0x33
0x45 0x55 0x52 0x20 0x20 0x20 0x31 0x31 0x33 0x30 0x20 0x20 0x20 0x20 0x20 0x20
0x30 0x20 0x20 0x20 0x32 0x33 0x37 0x38 0x39 0x32 0x20 0x20 0x20 0x33 0x39 0x36
   0x34 0x2e 0x38 0x37 0x1a])

(defn string->input-stream
  "Convert a string into a byte-array input stream."
  [s]
  (io/input-stream (byte-array (map byte s))))

(deftest read-bytes-test
  (let [stream (string->input-stream dbase-sample)]
    (is (= 3 (first (sut/read-bytes stream 1))))
    (is (= 119 (first (sut/read-bytes stream 1 1))))
    (is (= 1 (first (sut/read-bytes stream 1))))
    (let [s (sut/read-bytes stream 2)]
      (is (= 1 (first s)))
      (is (= 0 (second s))))))

(deftest read-byte-test
  (let [stream (string->input-stream dbase-sample)]
    (is (= 3 (sut/read-byte stream)))
    (is (= 119 (sut/read-byte stream 2)))
    (is (= 1 (sut/read-byte stream)))))

(deftest bytes->int-test
  (is (= 3 (sut/bytes->int (byte-array [3 0 0 0]))))
  (is (= 266 (sut/bytes->int (byte-array [10 1 0 0]))))
  (is (not (= 3 (sut/bytes->int (byte-array [10 0 0 0])))))
  (is (thrown? AssertionError (sut/bytes->int (byte-array [0])))))

(deftest bytes->short-test
  (is (= 3 (sut/bytes->short (byte-array [3 0]))))
  (is (= 266 (sut/bytes->short (byte-array [10 1]))))
  (is (thrown? AssertionError (sut/bytes->int (byte-array [0])))))

(deftest next-byte?-test
  (let [stream (string->input-stream "123456")]
    (is (true? (sut/next-byte? stream (partial = 49))))
    (is (true? (sut/next-byte? stream (partial = 49))))))

(deftest parse-last-update-time-test
  (let [stream (io/input-stream (byte-array [0x77 0x0a 0x01]))]
    (is (= (java.util.Date. 119 10 1) (sut/parse-last-update-time stream)))))

(deftest parse-metadata-test
  (let [stream (string->input-stream dbase-sample)
        expected {:dbf-version 3 :last-update (java.util.Date. 119 10 1)
                  :num-records 1 :header-length 289 :record-length 67}]
    (is (= expected (sut/parse-dbase-metadata stream)))))

(deftest parse-field-test
  (let [stream (string->input-stream dbase-sample)
        expected {:name "KNQ", :type \C, :length 3, :precision 0 :work-area-id 1, :flags 0}]
    (sut/parse-dbase-metadata stream)
    ;(.skip stream 23)
    (is (= expected (first (sut/parse-dbase-fields stream))))))

(deftest field-definition->records-test
  (let [data {:fields [{:name "t"} {:name "t2"} {:name "t3"}]
              :records [["a" "b" "c"]
                        [1 2 3]]}
        records (:records (sut/field-definition->records data))]
    (is (= [{:t "a" :t2 "b" :t3 "c"} {:t 1 :t2 2 :t3 3}] records))))
